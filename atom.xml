<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://wuyadi.github.io</id>
    <title>一个兴趣使然的程序员</title>
    <updated>2021-02-08T10:02:13.998Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://wuyadi.github.io"/>
    <link rel="self" href="https://wuyadi.github.io/atom.xml"/>
    <subtitle>知耻近乎勇</subtitle>
    <logo>https://wuyadi.github.io/images/avatar.png</logo>
    <icon>https://wuyadi.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, 一个兴趣使然的程序员</rights>
    <entry>
        <title type="html"><![CDATA[做面试官一周有感]]></title>
        <id>https://wuyadi.github.io/post/zuo-mian-shi-guan-yi-zhou-you-gan/</id>
        <link href="https://wuyadi.github.io/post/zuo-mian-shi-guan-yi-zhou-you-gan/">
        </link>
        <updated>2020-09-18T12:47:26.000Z</updated>
        <content type="html"><![CDATA[<p>因为公司在996之后，任务量还是没有完全的消化。领导决定给我们组添加两个同事儿，然后让我作为初面面试官。然后我开始了诚惶诚恐的面试官体验。</p>
<p>首先是简历的筛选，真的是五味杂陈。</p>
<ul>
<li>有的同学写了很多公司的项目，但是通篇都是业务的内容，没有体现自己在团队中的作用，没有表达出自己做了什么；</li>
<li>有的同学写了很多技术栈，但是问起来又没有实战经验和技能；</li>
<li>有的同学字体选的偏小，看起来很累。</li>
</ul>
<p>再次是面试的感觉，在面试的过程中，我喜欢让面试者分享工作中做的有意思，有激情的事情。在这一周多的面试中没有一个面试小伙儿可以分享一个有意思的故事，大多小伙的表情是迷茫的，然后说每天都在做业务。做业务很正常，但是没有积累和沉淀，反思就有点差劲了。</p>
<p>最后有很多phper对于代码，对于作品没有追求的程序员是没有追求的，这样无疑很可怕，他产出的代码估计后期需要更多的同事去维护。</p>
<h5 id="以人为鉴可以知得失-争取在以后的工作和生活中不要犯以上的这种错误小错误啊">以人为鉴,可以知得失。争取在以后的工作和生活中不要犯以上的这种错误，小错误啊。</h5>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[奇怪的bug]]></title>
        <id>https://wuyadi.github.io/post/qi-guai-de-bug/</id>
        <link href="https://wuyadi.github.io/post/qi-guai-de-bug/">
        </link>
        <updated>2020-07-23T06:43:58.000Z</updated>
        <content type="html"><![CDATA[<h3 id="前情">前情：</h3>
<p>在更新了一个数据权限的模块之后，测试同学说有个权限的bug。在检查代码后，发现了罪魁祸首。</p>
<h3 id="开始">开始：</h3>
<pre><code class="language-php"> $keys = ['callerNum','calleeNum','agentName','agentID','customer_name','phone','ID_number','birth'];
        $phoneKeys = ['callerNum','calleeNum','phone'];
        $ID_numbers = ['ID_number'];
        $leftKeys = ['birth'];
        foreach ($data as $key =&gt; $value) {
            if(is_array($value)){
                $data[$key] = $this-&gt;withAllSecret($value);
            }else{
                if($key &amp;&amp; in_array($key,$keys)){
</code></pre>
<h3 id="分析">分析：</h3>
<p>在[官网]: https://www.php.net/manual/zh/function.in-array.php</p>
<p>对于in_array这个方法的解释为：in_array — 检查数组中是否存在某个值</p>
<pre><code class="language-php">in_array ( mixed $needle , array $haystack , bool $strict = false ) : bool
</code></pre>
<p>所以in_array()函数的value值会与搜索的值比较，如果不加第三个参数，in_array()会把搜索的类型强制转换成和value值一样进行比较。</p>
<p>所以，上面的搜索值 为‘h232’ 在和value = 0 进行比较的时候 ‘h234’强制转换成了number 0</p>
<h3 id="结论">结论：</h3>
<p>在使用in_array方法时，尽量使用第三个参数，避免因为类型转换，导致程序走向歧途。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[从PHP到GO之导出数据]]></title>
        <id>https://wuyadi.github.io/post/cong-php-dao-go-zhi-dao-chu-shu-ju/</id>
        <link href="https://wuyadi.github.io/post/cong-php-dao-go-zhi-dao-chu-shu-ju/">
        </link>
        <updated>2020-03-25T12:57:13.000Z</updated>
        <content type="html"><![CDATA[<h3 id="前情">前情：</h3>
<p>生产环境有客户经常从ES中导出不同时段的数据，一天数据大概有12W，现有的php导出速度在优化之后一次导出耗时需要27-35分钟，所以有了这次优化。</p>
<h3 id="开始">开始：</h3>
<h4 id="hbase-es">HBASE + ES</h4>
<p>因为现在的主要耗时在于从es获取数据时的耗时比较久，首先尝试了，将相对大的数据字段存储到HBASE，然后每次查询都从es获取ID，再从HBASE获取文本的数据。经测试从ES + HBASE比单纯ES快，但是效果不显著，还是不能满足客户需要。</p>
<h4 id="从php到golang">从PHP到Golang</h4>
<p>在改造了存储结构没有好的结果的时候，从头理了一下整个流程。发现因为语言的限制php每次只有一个并发从ES取数据，那么我们使用高并发的语言GO来并发的从ES拿数据，速度应该会提升不少。选中了常用的go-for-es插件olivere/elastic.v5 。</p>
<p>首先我们再main里面以10个<em>go</em>routine从ES拿数据。</p>
<pre><code class="language-go">    count := 10
	ch := make(chan bool, count)
	for i := 0; i &lt; count; i++ {
		go queryEs(ch, i)
	}
	for i := 0; i &lt; count; i++ {
		&lt;-ch
	}
    sliceQuery := NewSliceQuery().Id(i).Max(10)
	boolQ := elastic.NewBoolQuery()
	boolQ.Must(elastic.NewMatchQuery(&quot;ai_status&quot;, 3))
	boolQ.Filter(elastic.NewRangeQuery(&quot;create_time&quot;).Gt(1583337600))
	boolQ.Filter(elastic.NewRangeQuery(&quot;create_time&quot;).Lt(1585151999))
	svc := client.Scroll(&quot;index&quot;).Query(boolQ).Slice(sliceQuery).Size(800)
</code></pre>
<p>然后就是对数据的处理：</p>
<pre><code class="language-go">    result, err := svc.Do(context.TODO())
		if err == io.EOF {
			break
		}

		if err != nil {
			//fmt.Printf(err)
			break
		}

		for _, r := range result.Hits.Hits {
			jsonstring := *r.Source
			var source Source
			err = json.Unmarshal(jsonstring, &amp;source)
</code></pre>
<p>经测试导出数据20W条数据只需要10分钟</p>
<h3 id="结论">结论：</h3>
<p>在觉得做到的最优解的时候，换个思路，跳出僵化思维，或许会有意外的收获。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[phpexcel性能瓶颈及其优化 III]]></title>
        <id>https://wuyadi.github.io/post/phpexcel-xing-neng-ping-jing-ji-qi-you-hua-ii/</id>
        <link href="https://wuyadi.github.io/post/phpexcel-xing-neng-ping-jing-ji-qi-you-hua-ii/">
        </link>
        <updated>2020-03-22T12:05:39.000Z</updated>
        <content type="html"><![CDATA[<h3 id="前情">前情：</h3>
<p>再回头复查的时候，发现我始终局限于使用ExcelUtil或者 <a href="https://phpspreadsheet.readthedocs.io/">PhpSpreadsheet</a> ，我们就算分批取数据，但是excel本身的内存占用还是会累积，一个100W数据的导出，还是会引起服务器的内存溢出。</p>
<h3 id="开始">开始：</h3>
<p>有网友推荐使用</p>
<p>，有介绍说：<strong>Never run out of memory with PHPExcel again.</strong></p>
<p>替换后，查看服务器资源占用，没有看到内存持续增长。</p>
<h3 id="分析">分析：</h3>
<p>XLSXWriter不是一直保存一个对象来进行增删改查，而是通过增量写文件的方式来进行excel的导出。所以不会随着导出的数据量增长，而占用更多的内存。</p>
<h3 id="结论">结论：</h3>
<p>在使用XLSXWriter替换导出组件之后，系统的导出时长完全受限于从数据库读取数据。这块就要从数据查询语句优化做起。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[phpexcel性能瓶颈及其优化 II]]></title>
        <id>https://wuyadi.github.io/post/phpexcel-xing-neng-ping-jing-ji-qi-you-hua-i/</id>
        <link href="https://wuyadi.github.io/post/phpexcel-xing-neng-ping-jing-ji-qi-you-hua-i/">
        </link>
        <updated>2019-07-11T12:46:04.000Z</updated>
        <content type="html"><![CDATA[<h4 id="前情"><strong>前情：</strong></h4>
<p>前面简单的优化了导出的报错以及资源限制，这两天来复查的时候，发现导出数量达到1W的时候 ，导出速度就会越来越慢。简单的盘一下。</p>
<h4 id="开始"><strong>开始：</strong></h4>
<p>代码如下：</p>
<pre><code class="language-php">if (!empty($param['tag_name'])) {
            $targetModel = M(&quot;target_user_type&quot;);
            $session_ids = $targetModel-&gt;where([
                'tag_name' =&gt; $param['tag_name'],
                'scene_id' =&gt; $param['scene_id']
            ])-&gt;field(&quot;session_id&quot;)-&gt;select();
            foreach ($session_ids as $keytemp=&gt;$valuetemp){
                $session_arr[] = $valuetemp['session_id'];
            }
            if (count($session_arr) &gt; 0) {
                $where['session_id'] = [&quot;in&quot;,$session_arr];
            }else{
                $this-&gt;myAjaxReturn(0, &quot;&quot;,[&quot;fieldList&quot;=&gt;[],&quot;dataList&quot;=&gt;[] , &quot;mapData&quot; =&gt; []],0);
            }
        }

        $data = $this-&gt;getReportData($where,$param,$session_arr,false , true);
</code></pre>
<h4 id="分析"><strong>分析：</strong></h4>
<p>由上述代码得知拿到查询条件之后，根据条件一次性获取所有导出数据。这样会引起两个问题：</p>
<ul>
<li>由php本身的垃圾回收机制导致的大数组处理占用内存飙升</li>
<li>一次性获取大量数据会导致mysql卡顿</li>
</ul>
<h4 id="问题解决">问题解决</h4>
<pre><code class="language-php">if (!empty($param['tag_name'])) {
            $targetModel = M(&quot;target_user_type&quot;);
            $session_arr = $targetModel-&gt;where([
                'tag_name' =&gt; $param['tag_name'],
                'scene_id' =&gt; $param['scene_id']
            ])-&gt;where($swhere)-&gt;getField('session_id',true);
            if (count($session_arr) &lt; 1) {
                $this-&gt;myAjaxReturn(0, &quot;&quot;,[&quot;fieldList&quot;=&gt;[],&quot;dataList&quot;=&gt;[] , &quot;mapData&quot; =&gt; []],0);
            }
        }else{
            $robotModel = intval($param['type']) == 1? M('robot_chat_converge_call_in'):M('robot_chat_converge');
            $session_arr = $robotModel-&gt;where($where)-&gt;order('id desc')-&gt;getField('session_id',true);
        }
        if(isset($where['add_time'])){
            unset($where['add_time']);
        }
        $totalData = 0;
        $writer = new \Home\Util\XLSXWriter();
        $sheet_name = &quot;Sheet1&quot;;
        if(isset($session_arr) &amp;&amp; count($session_arr)&gt;0){
            $new_array = array_chunk($session_arr,500);
            foreach ($new_array as $nkey =&gt; $val) {
                unset($exportData);
                $exportData = [];
                $where['session_id'] = [&quot;in&quot;,$val];
                $data = $this-&gt;getReportData($where,$param,$session_arr,false , true);
</code></pre>
<p>上述代码首先获取了全部的session_id 数组，然后分批获取导出数据，再执行导出。在导出一批数据之后unset掉临时数组减少内存占用，提升导出速度。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[phpexcel性能瓶颈及其优化 I]]></title>
        <id>https://wuyadi.github.io/post/phpexcel-xing-neng-ping-jing-ji-qi-you-hua/</id>
        <link href="https://wuyadi.github.io/post/phpexcel-xing-neng-ping-jing-ji-qi-you-hua/">
        </link>
        <updated>2019-02-02T02:25:10.000Z</updated>
        <content type="html"><![CDATA[<h2 id="php导出excel常见报错">PHP导出excel常见报错</h2>
<h3 id="导出报错-fatal-error-out-of-memory">导出报错 Fatal error: Out of memory</h3>
<p>Fatal error: Out of memory (allocated 1048576) (tried to allocate 393216 bytes)<br>
在程序中添加 ini_set(&quot;memory_limit&quot;,&quot;2080M&quot;);<br>
或者直接修改php.ini中的memory_limit<br>
memory_limit参数PHP可以占用的内存数，注意不要超过机器的实际内存。</p>
<h3 id="导出报错-502bad-gateway">导出报错 502bad gateway</h3>
<p>502是程序运行超时是nginx和php-fpm配置的问题。<br>
一般我们设置一下php-fpm.conf中的request_terminate_timeout之后重启PHP-FPM和nginx服务就可以了。</p>
<h3 id="导出报错-该网页无法正常运作-目前无法处理此请求-http-error-500">导出报错 该网页无法正常运作 目前无法处理此请求。HTTP ERROR 500</h3>
<p>在测试环境下修改php.ini开启<br>
display_errors = On<br>
display_startup_errors = On<br>
并重启服务，然后根据报错相应处理</p>
<h2 id="由以上报错我们可以得出-php的性能瓶颈在于服务器性能当导出数量大于1w条的时候随着php使用服务器内存的增加导出速度在相应的下降">由以上报错我们可以得出 php的性能瓶颈在于服务器性能，当导出数量大于1W条的时候，随着PHP使用服务器内存的增加，导出速度在相应的下降。</h2>
<h2 id="php导出excel的优化">PHP导出EXCEL的优化</h2>
<h3 id="不要在写入excel的时候进行计算">不要在写入EXCEL的时候进行计算</h3>
<h3 id="不要再大数据的时候设置单元格样式">不要再大数据的时候设置单元格样式</h3>
<h3 id="分批次写入">分批次写入</h3>
<h3 id="使用phpexcel_settingssetcachestoragemethod-降低程序对内存的消耗">使用PHPExcel_Settings::setCacheStorageMethod() 降低程序对内存的消耗</h3>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[抽象类、接口的定义、区别和使用场景]]></title>
        <id>https://wuyadi.github.io/post/chou-xiang-lei-jie-kou-de-ding-yi-qu-bie-he-shi-yong-chang-jing/</id>
        <link href="https://wuyadi.github.io/post/chou-xiang-lei-jie-kou-de-ding-yi-qu-bie-he-shi-yong-chang-jing/">
        </link>
        <updated>2018-09-09T09:34:27.000Z</updated>
        <content type="html"><![CDATA[<h2 id="抽象类的定义">抽象类的定义</h2>
<p>PHP 5 支持抽象类和抽象方法。定义为抽象的类不能被实例化。任何一个类，如果它里面至少有一个方法是被声明为抽象的，那么这个类就必须被声明为抽象的。被定义为抽象的方法只是声明了其调用方式（参数），不能定义其具体的功能实现。</p>
<p>继承一个抽象类的时候，子类必须定义父类中的所有抽象方法；另外，这些方法的访问控制必须和父类中一样（或者更为宽松）。例如某个抽象方法被声明为受保护的，那么子类中实现的方法就应该声明为受保护的或者公有的，而不能定义为私有的。此外方法的调用方式必须匹配，即类型和所需参数数量必须一致。例如，子类定义了一个可选参数，而父类抽象方法的声明里没有，则两者的声明并无冲突。 这也适用于 PHP 5.4 起的构造函数。在 PHP 5.4 之前的构造函数声明可以不一样的。</p>
<h2 id="接口的定义">接口的定义</h2>
<p>使用接口（interface），可以指定某个类必须实现哪些方法，但不需要定义这些方法的具体内容。<br>
接口是通过 interface 关键字来定义的，就像定义一个标准的类一样，但其中定义所有的方法都是空的。<br>
接口中定义的所有方法都必须是公有，这是接口的特性。</p>
<h3 id="tips">TIPS</h3>
<p>实现多个接口时，接口中的方法不能有重名。<br>
接口也可以继承，通过使用 extends 操作符。<br>
类要实现接口，必须使用和接口中所定义的方法完全一致的方式。否则会导致致命错误。<br>
接口中也可以定义常量。接口常量和类常量的使用完全相同，但是不能被子类或子接口所覆盖。</p>
<h2 id="抽象类和接口的区别">抽象类和接口的区别</h2>
<p>对接口的继承使用implements,抽象类使用extends.<br>
接口中不可以声明变量,但可以声明类常量.抽象类中可以声明各种变量<br>
接口没有构造函数,抽象类可以有<br>
接口中的方法默认为public,抽象类中的方法可以用public,protected,private修饰<br>
一个类可以继承多个接口,但只能继承一个抽象类</p>
]]></content>
    </entry>
</feed>