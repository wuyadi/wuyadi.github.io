{"posts":[{"title":"《致知了》                                                                         -宣克炅","content":"闭嘴！说你呢高高在上一片聒噪声平添几分燥热自以为聪明肥头大耳土堆里蛰伏5年以上才爬出阴间却只会用屁股唱夏日里的赞歌不知人间疾苦酷暑!","link":"https://wuyadi.github.io/post/lesslesszhi-zhi-liao-greatergreater-xuan-ke-jiong/"},{"title":"2021年终总结","content":"代码方面由phper到javaer，现在是一个高级的phper+中级的javaer。换了语言之后，微服务的方案就可以顺理成章的安排上。拆出了exam，base，train，等等模块，在客户环境上线也没有问题，解耦极大地提升了代码的优雅程度，也方便运维同学部署，微服务java确实比php香的太多。今年还修了不少swoft框架的bug，一度以为swoole是php的未来，现在才发现php没有未来。管理方面今年正式有了来自公司的任命，也有了做管理的一些津贴，做一些事情也更加有底气。整体来说还是一个管理的新人，对待很多事情的处理方法有待提升。同时也有一丢丢心得和经验。比较期望自己和小组的同学都可以有向上的态度和对于学习的热情，知易行难。生活方面今年在生活方面是有里程碑事件的，在七年的爱情长跑后，终于和小猪猪同学走进了婚姻的殿堂。以后不在是一个人了，角色转变带来的影响暂时对生活的没有太大的影响。期待下一次身份的转变（假装听到有个软软糯糯的声音爸爸~~）。总结总体来说21年是有进步和提升的，尤其在生活方面有里程碑事件。可惜事情有：疫情还是持续，没有坚持刷算法，没有持续健身锻炼。2022让我专注一点，自律使我自由。","link":"https://wuyadi.github.io/post/2021-nian-zhong-zong-jie/"},{"title":"Older","content":"IusedtoshutmydoorwhilemymotherscreamedinthekitchenI'dturnthemusicup,gethighandtrynottolistenToeverylittlefight,'causeneitheronewasrightIsworeI'dneverbelikethemButIwasjustakidbackthenTheolderIgetthemorethatIseeMyparentsaren'theroes,they'rejustlikemeAndlovingishard,itdon'talwaysworkYoujusttryyourbestnottogethurtIusedtobemadbutnowIknowSometimesit'sbettertoletsomeonegoItjusthadn'thitmeyetTheolderIgetIusedtowonderwhy,whytheycouldneverbehappyIusedtoclosemyeyesandprayforawhole'notherfamilyWhereeverythingwasfine,onethatfeltlikemineIsworeI'dneverbelikethemButIwasjustakidbackthenTheolderIgetthemorethatIseeMyparentsaren'theroes,they'rejustlikemeAndlovingishard,itdon'talwaysworkYoujusttryyourbestnottogethurtIusedtobemadbutnowIknowSometimesit'sbettertoletsomeonegoItjusthadn'thitmeyetTheolderIgetTheolderIgetthemorethatIseeMyparentsaren'theroes,they'rejustlikemeAndlovingishard,itdon'talwaysworkYoujusttryyourbestnottogethurtIusedtobemadbutnowIknowSometimesit'sbettertoletsomeonegoItjusthadn'thitmeyetTheolderIget","link":"https://wuyadi.github.io/post/older/"},{"title":"用python脚本删除无效redis key","content":"这天运维找我反馈说zgyh这个客户的redis内存越来越高，让我们先自查下是否有程序不合理的一直往redis写key。在排查了javagopython和php的代码后，我信心满满的给了他一个key的列表和统计计数的脚本#!/bin/bashA=$0B=${A##*/}C=${B%.*}running_file_name=$Crunning_flag=&quot;run.$running_file_name&quot;REDIS_CLIENT='redis-cli-axxxx-x'functionprocess{echo$0index=-1count=0step=100000while((index!=0))doif[$index-le0];thenindex=0fiecho&quot;scan$indexmatch$1count$step&quot;|$REDIS_CLIENT&gt;$running_file_name.cachereadindex&lt;&lt;&lt;`head-1$running_file_name.cache`readinc&lt;&lt;&lt;`cat$running_file_name.cache|wc-l`inc=$((inc-1))if[$?-ne0];thenbreakficount=$((count+inc))doneecho&quot;$1count:&quot;$count}#if[$#-ne1];thenecho&quot;$0&lt;pars&gt;&quot;exit0fi#if[-f&quot;$running_flag&quot;];thenecho&quot;isrunning...&quot;exit0fi#touch$running_flag#echo&quot;processing....&quot;echo$*process$*#rm-rf$running_flag#echo&quot;ok!&quot;和查bigkey的方法redis-cli-c-p6379-a密码--bigkeys运维反馈bigkeys因为版本问题访问不了，根据我提供的业务key查的数量最大的也就W。但是现在生产的key已经达到了几百W。过了几天，运维反馈说找到了那些幽灵的key，是32位的随机字幕+数字，没有赋值，最要命的是没有设置过期时间且确定是从我们的服务机器发出的请求。再次走查代码，依旧没有头绪，测试环境的redis环境也没有这些奇怪的key。殚思竭虑两天后，猛地想起这个数据格式和php的session_id很类似。于是检查php的入口方法，果然找到问题。$time=$this-&gt;isSession();if($this-&gt;skipCheck)returntrue;这个isSession方法protectedfunctionisSession(){if($this-&gt;AccessField=='FILE'){return$this-&gt;isFSession();}else{return$this-&gt;isRSession();}}在类型不是FILE的情况下会走isRSessionprivatefunctionisRSession(){$PHPSESSID=$_COOKIE['PHPSESSID'];if(empty($PHPSESSID)){return;}$data=S($PHPSESSID);if(empty($data)){return;}/*从缓存服务器同步到本地*/if($data['SYNCH']){$data=array(&quot;DATA&quot;=&gt;$data['DATA'],&quot;EXPIRE&quot;=&gt;time(),&quot;REGIST&quot;=&gt;time());$data['SYNCH']=false;/*更新缓存服务器状态*/}if(!empty($_SESSION[$this-&gt;AccessName])){/*已同步到现在的服务器上*/return$_SESSION[$this-&gt;AccessName]['EXPIRE'];}}问题就出在S($PHPSESSID)这句，S方法内容如下functionS($name,$value='',$options=null){static$cache='';if(strtoupper(C('DATA_CACHE_TYPE'))=='REDISMS'){$cache=Think\\Cache\\Driver\\Redisms::getInstance();if(''===$value){//获取缓存return$cache-&gt;get($name);}elseif(is_null($value)){//删除缓存return$cache-&gt;rm($name);}else{if(is_array($options)){$expire=isset($options['expire'])?$options['expire']:NULL;}else{$expire=is_numeric($options)?$options:NULL;}return$cache-&gt;set($name,$value,$expire);}}if(is_array($options)){//缓存操作的同时初始化$type=isset($options['type'])?$options['type']:'';$cache=Think\\Cache::getInstance($type,$options);}elseif(is_array($name)){//缓存初始化$type=isset($name['type'])?$name['type']:'';$cache=Think\\Cache::getInstance($type,$name);return$cache;}elseif(empty($cache)){//自动初始化$cache=Think\\Cache::getInstance();}if(''===$value){//获取缓存return$cache-&gt;get($name);}elseif(is_null($value)){//删除缓存return$cache-&gt;rm($name);}else{//缓存数据if(is_array($options)){$expire=isset($options['expire'])?$options['expire']:NULL;}else{$expire=is_numeric($options)?$options:NULL;}return$cache-&gt;set($name,$value,$expire);}}坏就坏在这边没有缓存会去setMemcache.class.php创建缓存的代码;publicfunctionwrite($sessID,$sessData){return$this-&gt;handle-&gt;set($this-&gt;sessionName.$sessID,$sessData,0,$this-&gt;lifeTime);}$this-&gt;lifeTime取得protected$lifeTime=3600;protected$sessionName='';protected$handle=null;/***打开Session*@accesspublic*@paramstring$savePath*@parammixed$sessName*/publicfunctionopen($savePath,$sessName){$this-&gt;lifeTime=C('SESSION_EXPIRE')?C('SESSION_EXPIRE'):$this-&gt;lifeTime;好死不死，配置中SESSION_EXPIRE是0。所以改配置中SESSION_EXPIRE，确保后续数据的及时清理。但是之前redis中key怎么清理呢。找了下轮子没有现成的，写了一个python的脚本importredis#匹配test:开头[0-9]结尾的keyprefix='*'conn=redis.Redis(host='172.20.199.5',port=6379,password=&quot;***&quot;)i=0s=0forkeyinconn.scan_iter(match=prefix,count=1000):ttltime=conn.ttl(key)i=i+1if((ttltimeisNoneorttltime==-1)andlen(key)==32andconn.type(key).decode()=='string'andnotconn.get(key)):#删除匹配到的没有过期时间的keyprint(key,'-value=',conn.get(key))print(key,'-key=',conn.type(key))conn.delete(key)s=s+1print(key,'-delnumber=',s)print('totalkey',i,'-&gt;del',s)完美。今天小雪晚来天欲雪，能饮一杯无？","link":"https://wuyadi.github.io/post/yong-python-jiao-ben-shan-chu-wu-xiao-redis-key/"},{"title":"陈年喜 ·《双鱼铜镜》","content":"这面铜镜据说产自金代它有着北方浓烈的质地两尾鲤鱼一直活着它们游向恩爱游向朝代深处它曾经悬于闺室映过一张姣好的颜容她的亲人耽于征战策马长城或埋骨于雨定河边如今一面镜子沉默不语它一路经过的村庄风雨兴亡被穿窗而至的一缕晨光再次照见我曾经查阅过史籍知道铜在商代已有冶炼这也说明至金代铜早已如火纯青在这面镜子的某处斑点上我还是看见了疼痛的瑕疵河山易碎人世多苦注浆的一瞬那被炭火灼烤的人从眼里滴下了一滴铸浆不要向沉默之物询问何以沉默不要打听荻花雪白的缘由飘泊的人被天涯所累的人你要保护好体内古老的铜镜我们在暗处它在明处当你试图解下某些渴意它正好映见门前的井水","link":"https://wuyadi.github.io/post/chen-nian-xi-lesslessshuang-yu-tong-jing-greatergreater/"},{"title":"低效能程序员的行为与思维，共勉","content":"不写单元测试。不主动学习，不看书。总是拿没时间作为借口。不会做任务拆解，也没有记录拆解的任务。做事没耐心。不Review自己的代码，做过的事情，犯的错误。从不了解架构，不了解设计（设计就是架构）。不了解敏捷开发，更没有想了解的意愿，也不会去实施。ScrumStandup、KanbanBoard是能提高工作效率的。喜欢埋怨别人，说在公司学不到技术，也不积极主动学习。认为重复的CRUD很无趣，总想着换个工作能好点。对每天做的事情不做记录。这里不是指日报，这里指的是你对每天工作是否有计划，将大的任务，拆成足够小的子任务。按优先级，有次序得完成任务。喜欢口述需求，不做文本化记录、转达。来自同事喜欢“多线程”处理任务。也就是同时做多件事。命名无关紧要。从不重构以前的代码。喜欢一个方法写一大段代码。对自己的代码质量没有追求。没有匠心精神，只是个开发（Developer），而不是工程师（Engineer）。和上面一样，认为敲代码来钱快，觉得以后要转其他职业的。来自以前的一些同事。喜欢盲目追逐新技术，不深入了解类似技术的本质。喜欢闭门造车，不了解业界成熟的内容本质，不会多维度比较。喜欢看“垃圾博客”（这里特指CSDN上的大部分博客），而不是看书了解技术。对别人产生严重依赖。例子：连SQL的关键字AFTER也要去问别人得到答案，而不是自己搜索。工作能力很差，但总喜欢教别人工作之外的事情（例如“做人”的那些“大道理”）。思维固化，不听取他人意见，只会反对（无理无据，没有拿出实际论证的内容那种）。在没有完全掌握或了解的情况下，擅自使用“新技术”。例如在没有完全掌握多线程和函数式编程的情况下，喜欢&quot;滥用&quot;多线程、函数式编程。我说的掌握，前提是看过相应的书籍，例如《Java8实战》、《函数式编程》、《Java并发编程实战》这些书籍，并且真正理解其中的内容。在不了解KafkaStreams的情况下，直接引入对应的SpringCloudStream进行新项目的开发，从而引入天坑。碎片化工作。上班一半以上时间都是在刷手机摸鱼，没有完整的大段的深度工作的时间，把工作时间碎片化了。喜欢将5天的事情，拖到6天“做完”。当然，这里和公司也有关系，垃圾公司是比较喜欢996，大小周，以为能多压榨下员工。从不看计算机操作系统的相关内容。喜欢过度设计。这个“过度”，仁者见仁，智者见智，分不同场景下有不同的解释。引用别人的内容，从不标注出处。融入世俗,没有享受过用编程进行创造or自我表达的快乐来自https://www.v2ex.com/t/801228","link":"https://wuyadi.github.io/post/di-xiao-neng-cheng-xu-yuan-de-xing-wei-yu-si-wei-gong-mian/"},{"title":"With great power comes great responsibility","content":"蜘蛛侠的叔叔曾经说过：能力越大，责任越大。以我国是按劳分配为大前提，则推导出：赚钱越多，劳动越多。而大家都是每天只有24小时的人，能劳动越多，说明能力越大。即推导出：赚的越多，责任越大。比如年轻人月收入一万，已经算不错的了吧，按21.75工作日算，日薪460元。某明星一天208万，相当于4521个年轻人的能力和责任。也就是说，只要某明星不躺平，即使有4521名年轻人躺平，也不影响国家发展。新东方有三四万名员工，只需要雇佣七八个不躺平版本某明星，就足够了。如果按资产算，俞敏洪身家280亿左右，一个普通的九五后资产就按10万算好了，俞敏洪的责任相当于28万人，相当于一个小县城，我们称为县级责任人。马云责任相当于四百多万人的责任，一个二线城市了，我们称为市级二品责任人。当然，相当于一线城市的市级一品责任人国内还没出现，但是贝佐斯、马斯克、比尔盖茨这些国外高手，已经达到了市级准一品境界。中国九五后大概1.5亿，也就是说，哪怕全都躺平，你们只要找到三四十个马云，或者五六百个俞敏洪，国家也有未来。当然，那肯定是不好找的，但是各个级别的高手凑一凑，大概率够的。薇娅之前进入了财富榜五百强，90亿，差不多区域范围百强镇级别了吧，堪堪守门员。也就是说，这个级别的，上面还有将近五百个，那这个之下呢，像某明星这样村级高手，应该不少的。毕竟像王健林这样的市级三品高手，随手一个小目标就能击败中下等村级了。所以各位村级乡级镇级县级市级五品四品三品二品的人呀，只要你们不躺平，国家就有希望。争取早日出现比肩国外准一品境界的高手，甚至真正的市级一品，省级，国级，行星级，恒星级，宇宙级，不朽级，永恒级。你们的目标是星辰大海，不要往下看那些躺平的年轻人，你们对待年轻人躺平的态度应该像真正的高手那样：“哼，蝼蚁”。学学当年的斗帝萧炎，力争上游，勇攀高峰，不畏艰险，排除万难，从街道级别的斗者起步，三十年河东，三十年河西，莫欺中老年不够富。学学RPG里的勇者，一个级别一个级别的升级，连续突破了七八十级，最终的目标也是大魔王和大魔王背后的大大魔王，而不是整天盯着村里的史莱姆（隔壁那个变成魔王的史莱姆不算）。学学左晖，尽管已经突破成为了县级高手，依然还想突破，虽然最终陨落，但他勇敢的心值得你们向往。资本无限的持续增长本就是逆天而行，凶险无比，但是你们不怕。要向上看，向远看，不要看这些躺平的蝼蚁，他们不及你们的十万百万分之一。加油吧，资本人。","link":"https://wuyadi.github.io/post/with-great-power-comes-great-responsibility/"},{"title":"代码规范原则","content":"KeepitSimpleandStupid原则在设计、制造当中以简约、简单为标准。因为简约、简单，才易于生产，易于维护，更易于操作要谦虚，不要认为自己是个天才将你的任务分解为4-12小时的子任务。把你的问题拆分成多个小问题。每个问题用一个或者很少的几个类来解决掉。保持你的方法足够小，每个方法永远不要超过30-40行代码。每个方法都应该只处理一个小小的问题，不要搞太多usescase进去。让你的类也小点，原则和上面的方法是一样的。先解决问题，然后开始编码。不要一边编码，一边解决问题。这样做也没什么错，但你有能力提前把事情切分成多个小的块，然后开始编码可能是比较好的。另外行数还不是为了衡量质量的标准，只是有个基本的尺子而已。不要害怕干掉代码。重构和重做是两个非常重要的方面。DRY原则Don'tRepeatYourself组合原则设计时考虑拼接组合通俗原则接口设计避免标新立异吝啬原则除非确无它法,不要编写庞大的程序透明性原则设计要可见，以便审查和调试补救原则出现异常时，马上退出并给出足够错误信息缄默原则如果一个程序没什么好说的，就沉默","link":"https://wuyadi.github.io/post/dai-ma-gui-fan-yuan-ze/"},{"title":"关于高级程序员的思考(ˇˍˇ)","content":"这周面试了一个工作了11年的前辈，整个面试过程情绪波动比较大，感触良多。以下是面试老哥的部分简历：刚开始面试的时候我是有点虚的，毕竟眼前的这位可能是一个大佬。但是随着交流我发现事情并不简单。后端知识点：jvm的相关知识点答得含糊其辞，对于内存回收也没有说到点。他解释说最近两年都在做架构工作，java基础功有点拉下了。数据库：我：对于select*fromuserswherecreated_at&gt;&quot;20190802&quot;andphonelike&quot;1820222%&quot;orderbyuiddesclimit10;/*PRIMARYKEY(`id`),UNIQUEKEY`uid`(`uid`)USINGBTREE,KEY`created_at`(`created_at`,`phone`)USINGBTREE*/这个查询语句，你怎么进行优化？老哥：首先这个*是不对的，要根据业务需要进行获取。（长达五分钟的沉默）老哥：这边排序为什么不用id？老哥：这边uid排序确实没有id快，你能简单说明下它为什么要用id吗？快的原因是什么？可惜我最后还是没有听到回表啊，索引的实现原理啊。这让我对他专研技术的描述产生了怀疑。前端：问：请问你前端主要使用的什么框架？答：主要使用Jquery和layui做一些后台系统。我终于可以确定：这是一个老crudboy。仔细看了下他的简历发现，最近的一份工作是半年前。人到中年的程序员啊，怎么才能保持自己的核心竞争力呢？高级程序员，和中级的区别又在哪里呢？被迫转岗难道就是唯一的出路吗？我认为高级程序员，高在经验，在看问题的广度，更在技术的深度。程序员的安身立命之本永远是技术。","link":"https://wuyadi.github.io/post/guan-yu-gao-ji-cheng-xu-yuan-de-si-kao-v_v/"},{"title":"做面试官一周有感","content":"因为公司在996之后，任务量还是没有完全的消化。领导决定给我们组添加两个同事儿，然后让我作为初面面试官。然后我开始了诚惶诚恐的面试官体验。首先是简历的筛选，真的是五味杂陈。有的同学写了很多公司的项目，但是通篇都是业务的内容，没有体现自己在团队中的作用，没有表达出自己做了什么；有的同学写了很多技术栈，但是问起来又没有实战经验和技能；有的同学字体选的偏小，看起来很累。再次是面试的感觉，在面试的过程中，我喜欢让面试者分享工作中做的有意思，有激情的事情。在这一周多的面试中没有一个面试小伙儿可以分享一个有意思的故事，大多小伙的表情是迷茫的，然后说每天都在做业务。做业务很正常，但是没有积累和沉淀，反思就有点差劲了。最后有很多phper对于代码，对于作品没有追求的程序员是没有追求的，这样无疑很可怕，他产出的代码估计后期需要更多的同事去维护。以人为鉴,可以知得失。争取在以后的工作和生活中不要犯以上的这种错误，小错误啊。","link":"https://wuyadi.github.io/post/zuo-mian-shi-guan-yi-zhou-you-gan/"},{"title":"php导出最终章","content":"产品新上了一个标注平台，主要功能是，标注asr识别不准的文字，然后重新提交训练提高asr的识别准确率。然后业务那边提了一个导出错误和正确文本对比的需求，听起来实现很容易，然后业务又说，错误的文本要用颜色标红区分出来。这个听起来也不难，同事小伙儿coding。。。问题来了，使用传统的ExcelUtil，代码如下Excel::create($exportName,function($excel)use($execlData,$keyword){$excel-&gt;sheet('score',function($sheet)use($execlData,$keyword){$sheet-&gt;rows($execlData);$count=count($execlData);for($i=1;$i&lt;$count;$i++){$line=$i+1;$objRichText=$this-&gt;dealKeyword($keyword,$execlData[$i][2]);$sheet-&gt;setCellValue('C'.$line,$objRichText);$objRichText1=$this-&gt;dealKeyword($keyword,$execlData[$i][3]);$sheet-&gt;setCellValue('D'.$line,$objRichText1);if(isset($execlData[$i-1])&amp;&amp;$execlData[$i][0]==$execlData[$i-1][0]){$sheet-&gt;mergeCells(&quot;A&quot;.($line-1).&quot;:A&quot;.($line));$sheet-&gt;mergeCells(&quot;B&quot;.($line-1).&quot;:B&quot;.($line));}$sheet-&gt;getStyle('A'.$line.':B'.$line)-&gt;getAlignment()-&gt;setHorizontal(PHPExcel_Style_Alignment::HORIZONTAL_CENTER);}});})-&gt;store('xls',$path);之后导出是可以导出，颜色也可以区分。但是在数据到100左右的时候，导出的excel尾部变成了乱码。在对ExcelUtil的各种参数进行调优和变量重置之后。小伙儿开始求助于我们，最终认定ExcelUtil不能实现这个需求。然后在google的时候发现python可以导出来fromxlsxwriter.workbookimportWorkbookimportreworkbook=Workbook('a.xlsx')worksheet=workbook.add_worksheet()color=workbook.add_format({'color':'red','bold':True})rc=re.compile('([0-9年月日]{2,})')sentence='2020年月12日母校初见。1月26日长烟落日孤城闭，2月9日神仙眷侣云比心'format_ls=rc.split(sentence)foriinrange(len(format_ls)-1,-1,-1):ifrc.fullmatch(format_ls[i]):format_ls.insert(i,color)#Prefixthewordwiththeformatprint(format_ls)row,col=2,1worksheet.write_rich_string(row,col,*format_ls)workbook.close()所以我们依葫芦画瓢，同样用xlsxwriter实现这个功能不就好了么。然后发现[xlsxwriter]:https://github.com/mk-j/PHP_XLSXWriter并没有write_rich_string这个方法。oops，这可不太妙。没有轮子就自己造轮子。通过阅读XLSXWriter的源码。复写了writeCell方法，在方法中新增逻辑如下：$cell_name=self::xlsCell($row_number,$column_number);if(is_array($value)&amp;&amp;isset($value[0]['style']['color'])){$str=&quot;&quot;;foreach($valueas$key=&gt;$val){if(isset($val['style']['color'])){$str=$str.'&lt;r&gt;&lt;rPr&gt;&lt;colorrgb=&quot;'.$val['style']['color'].'&quot;/&gt;&lt;/rPr&gt;&lt;t&gt;'.$val['text'].'&lt;/t&gt;&lt;/r&gt;';}}$file-&gt;write('&lt;cr=&quot;'.$cell_name.'&quot;s=&quot;'.$cell_style_idx.'&quot;t=&quot;inlineStr&quot;&gt;&lt;is&gt;'.$str.'&lt;/is&gt;&lt;/c&gt;');return;}代码完美运行。","link":"https://wuyadi.github.io/post/php-dao-chu-zui-zhong-zhang/"},{"title":"奇怪的bug","content":"前情：在更新了一个数据权限的模块之后，测试同学说有个权限的bug。在检查代码后，发现了罪魁祸首。开始：$keys=['callerNum','calleeNum','agentName','agentID','customer_name','phone','ID_number','birth'];$phoneKeys=['callerNum','calleeNum','phone'];$ID_numbers=['ID_number'];$leftKeys=['birth'];foreach($dataas$key=&gt;$value){if(is_array($value)){$data[$key]=$this-&gt;withAllSecret($value);}else{if($key&amp;&amp;in_array($key,$keys)){分析：在[官网]:https://www.php.net/manual/zh/function.in-array.php对于in_array这个方法的解释为：in_array—检查数组中是否存在某个值in_array(mixed$needle,array$haystack,bool$strict=false):bool所以in_array()函数的value值会与搜索的值比较，如果不加第三个参数，in_array()会把搜索的类型强制转换成和value值一样进行比较。所以，上面的搜索值为‘h232’在和value=0进行比较的时候‘h234’强制转换成了number0结论：在使用in_array方法时，尽量使用第三个参数，避免因为类型转换，导致程序走向歧途。","link":"https://wuyadi.github.io/post/qi-guai-de-bug/"},{"title":"从PHP到GO之导出数据","content":"前情：生产环境有客户经常从ES中导出不同时段的数据，一天数据大概有12W，现有的php导出速度在优化之后一次导出耗时需要27-35分钟，所以有了这次优化。开始：HBASE+ES因为现在的主要耗时在于从es获取数据时的耗时比较久，首先尝试了，将相对大的数据字段存储到HBASE，然后每次查询都从es获取ID，再从HBASE获取文本的数据。经测试从ES+HBASE比单纯ES快，但是效果不显著，还是不能满足客户需要。从PHP到Golang在改造了存储结构没有好的结果的时候，从头理了一下整个流程。发现因为语言的限制php每次只有一个并发从ES取数据，那么我们使用高并发的语言GO来并发的从ES拿数据，速度应该会提升不少。选中了常用的go-for-es插件olivere/elastic.v5。首先我们再main里面以10个goroutine从ES拿数据。count:=10ch:=make(chanbool,count)fori:=0;i&lt;count;i++{goqueryEs(ch,i)}fori:=0;i&lt;count;i++{&lt;-ch}sliceQuery:=NewSliceQuery().Id(i).Max(10)boolQ:=elastic.NewBoolQuery()boolQ.Must(elastic.NewMatchQuery(&quot;ai_status&quot;,3))boolQ.Filter(elastic.NewRangeQuery(&quot;create_time&quot;).Gt(1583337600))boolQ.Filter(elastic.NewRangeQuery(&quot;create_time&quot;).Lt(1585151999))svc:=client.Scroll(&quot;index&quot;).Query(boolQ).Slice(sliceQuery).Size(800)然后就是对数据的处理：result,err:=svc.Do(context.TODO())iferr==io.EOF{break}iferr!=nil{//fmt.Printf(err)break}for_,r:=rangeresult.Hits.Hits{jsonstring:=*r.SourcevarsourceSourceerr=json.Unmarshal(jsonstring,&amp;source)经测试导出数据20W条数据只需要10分钟结论：在觉得做到的最优解的时候，换个思路，跳出僵化思维，或许会有意外的收获。","link":"https://wuyadi.github.io/post/cong-php-dao-go-zhi-dao-chu-shu-ju/"},{"title":"phpexcel性能瓶颈及其优化 III","content":"前情：再回头复查的时候，发现我始终局限于使用ExcelUtil或者PhpSpreadsheet，我们就算分批取数据，但是excel本身的内存占用还是会累积，一个100W数据的导出，还是会引起服务器的内存溢出。开始：有网友推荐使用，有介绍说：NeverrunoutofmemorywithPHPExcelagain.替换后，查看服务器资源占用，没有看到内存持续增长。分析：XLSXWriter不是一直保存一个对象来进行增删改查，而是通过增量写文件的方式来进行excel的导出。所以不会随着导出的数据量增长，而占用更多的内存。结论：在使用XLSXWriter替换导出组件之后，系统的导出时长完全受限于从数据库读取数据。这块就要从数据查询语句优化做起。","link":"https://wuyadi.github.io/post/phpexcel-xing-neng-ping-jing-ji-qi-you-hua-ii/"},{"title":"phpexcel性能瓶颈及其优化 II","content":"前情：前面简单的优化了导出的报错以及资源限制，这两天来复查的时候，发现导出数量达到1W的时候，导出速度就会越来越慢。简单的盘一下。开始：代码如下：if(!empty($param['tag_name'])){$targetModel=M(&quot;target_user_type&quot;);$session_ids=$targetModel-&gt;where(['tag_name'=&gt;$param['tag_name'],'scene_id'=&gt;$param['scene_id']])-&gt;field(&quot;session_id&quot;)-&gt;select();foreach($session_idsas$keytemp=&gt;$valuetemp){$session_arr[]=$valuetemp['session_id'];}if(count($session_arr)&gt;0){$where['session_id']=[&quot;in&quot;,$session_arr];}else{$this-&gt;myAjaxReturn(0,&quot;&quot;,[&quot;fieldList&quot;=&gt;[],&quot;dataList&quot;=&gt;[],&quot;mapData&quot;=&gt;[]],0);}}$data=$this-&gt;getReportData($where,$param,$session_arr,false,true);分析：由上述代码得知拿到查询条件之后，根据条件一次性获取所有导出数据。这样会引起两个问题：由php本身的垃圾回收机制导致的大数组处理占用内存飙升一次性获取大量数据会导致mysql卡顿问题解决if(!empty($param['tag_name'])){$targetModel=M(&quot;target_user_type&quot;);$session_arr=$targetModel-&gt;where(['tag_name'=&gt;$param['tag_name'],'scene_id'=&gt;$param['scene_id']])-&gt;where($swhere)-&gt;getField('session_id',true);if(count($session_arr)&lt;1){$this-&gt;myAjaxReturn(0,&quot;&quot;,[&quot;fieldList&quot;=&gt;[],&quot;dataList&quot;=&gt;[],&quot;mapData&quot;=&gt;[]],0);}}else{$robotModel=intval($param['type'])==1?M('robot_chat_converge_call_in'):M('robot_chat_converge');$session_arr=$robotModel-&gt;where($where)-&gt;order('iddesc')-&gt;getField('session_id',true);}if(isset($where['add_time'])){unset($where['add_time']);}$totalData=0;$writer=new\\Home\\Util\\XLSXWriter();$sheet_name=&quot;Sheet1&quot;;if(isset($session_arr)&amp;&amp;count($session_arr)&gt;0){$new_array=array_chunk($session_arr,500);foreach($new_arrayas$nkey=&gt;$val){unset($exportData);$exportData=[];$where['session_id']=[&quot;in&quot;,$val];$data=$this-&gt;getReportData($where,$param,$session_arr,false,true);上述代码首先获取了全部的session_id数组，然后分批获取导出数据，再执行导出。在导出一批数据之后unset掉临时数组减少内存占用，提升导出速度。","link":"https://wuyadi.github.io/post/phpexcel-xing-neng-ping-jing-ji-qi-you-hua-i/"},{"title":"phpexcel性能瓶颈及其优化 I","content":"PHP导出excel常见报错导出报错Fatalerror:OutofmemoryFatalerror:Outofmemory(allocated1048576)(triedtoallocate393216bytes)在程序中添加ini_set(&quot;memory_limit&quot;,&quot;2080M&quot;);或者直接修改php.ini中的memory_limitmemory_limit参数PHP可以占用的内存数，注意不要超过机器的实际内存。导出报错502badgateway502是程序运行超时是nginx和php-fpm配置的问题。一般我们设置一下php-fpm.conf中的request_terminate_timeout之后重启PHP-FPM和nginx服务就可以了。导出报错该网页无法正常运作目前无法处理此请求。HTTPERROR500在测试环境下修改php.ini开启display_errors=Ondisplay_startup_errors=On并重启服务，然后根据报错相应处理由以上报错我们可以得出php的性能瓶颈在于服务器性能，当导出数量大于1W条的时候，随着PHP使用服务器内存的增加，导出速度在相应的下降。PHP导出EXCEL的优化不要在写入EXCEL的时候进行计算不要再大数据的时候设置单元格样式分批次写入使用PHPExcel_Settings::setCacheStorageMethod()降低程序对内存的消耗","link":"https://wuyadi.github.io/post/phpexcel-xing-neng-ping-jing-ji-qi-you-hua/"},{"title":"抽象类、接口的定义、区别和使用场景","content":"抽象类的定义PHP5支持抽象类和抽象方法。定义为抽象的类不能被实例化。任何一个类，如果它里面至少有一个方法是被声明为抽象的，那么这个类就必须被声明为抽象的。被定义为抽象的方法只是声明了其调用方式（参数），不能定义其具体的功能实现。继承一个抽象类的时候，子类必须定义父类中的所有抽象方法；另外，这些方法的访问控制必须和父类中一样（或者更为宽松）。例如某个抽象方法被声明为受保护的，那么子类中实现的方法就应该声明为受保护的或者公有的，而不能定义为私有的。此外方法的调用方式必须匹配，即类型和所需参数数量必须一致。例如，子类定义了一个可选参数，而父类抽象方法的声明里没有，则两者的声明并无冲突。这也适用于PHP5.4起的构造函数。在PHP5.4之前的构造函数声明可以不一样的。接口的定义使用接口（interface），可以指定某个类必须实现哪些方法，但不需要定义这些方法的具体内容。接口是通过interface关键字来定义的，就像定义一个标准的类一样，但其中定义所有的方法都是空的。接口中定义的所有方法都必须是公有，这是接口的特性。TIPS实现多个接口时，接口中的方法不能有重名。接口也可以继承，通过使用extends操作符。类要实现接口，必须使用和接口中所定义的方法完全一致的方式。否则会导致致命错误。接口中也可以定义常量。接口常量和类常量的使用完全相同，但是不能被子类或子接口所覆盖。抽象类和接口的区别对接口的继承使用implements,抽象类使用extends.接口中不可以声明变量,但可以声明类常量.抽象类中可以声明各种变量接口没有构造函数,抽象类可以有接口中的方法默认为public,抽象类中的方法可以用public,protected,private修饰一个类可以继承多个接口,但只能继承一个抽象类","link":"https://wuyadi.github.io/post/chou-xiang-lei-jie-kou-de-ding-yi-qu-bie-he-shi-yong-chang-jing/"}]}